//! Knockraven library
//!
//! This crate exposes a safe wrapper around a small C engine which generates
//! all possible port sequences given a list of candidate ports and a desired
//! sequence length.  It also contains helper types and asynchronous
//! primitives used by the Knockraven CLI.  The scanning logic itself lives in
//! `main.rs` but is defined in reusable functions here so it can be used as
//! a library in other Rust projects.

use std::ffi::c_void;
use std::sync::Arc;

use tokio::net::{TcpStream, UdpSocket};
use tokio::io::AsyncWriteExt;
use tokio::sync::Semaphore;
use tokio::time::{self, Duration};

/// Protocol enumeration used to indicate whether a knock should be sent over
/// TCP or UDP.  Currently only TCP and UDP are supported; additional
/// protocols could be added in the future by expanding this enum and the
/// corresponding send functions.
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Protocol {
    Tcp,
    Udp,
}

/// A simple structure combining a port with a transport protocol.
#[derive(Clone, Debug)]
pub struct PortProto {
    pub port: u16,
    pub protocol: Protocol,
}

// FFI bindings to the C sequence generation engine.  These functions are
// declared here and linked in via build.rs.  Safety: callers must ensure
// that pointers passed to these functions remain valid for the duration of
// the call and that callbacks do not unwind across the FFI boundary.
extern "C" {
    fn generate_sequences(
        ports: *const u16,
        num_ports: usize,
        seq_len: usize,
        callback: extern "C" fn(*const u16, usize, *mut c_void),
        user_data: *mut c_void,
    );
    fn count_sequences(num_ports: usize, seq_len: usize) -> u64;
}

/// Internal structure used to collect sequences from the C engine.  It is
/// wrapped in a mutex because the callback may be invoked from C while the
/// Rust thread holds a shared reference.  The mutex ensures that pushes are
/// synchronized in the unlikely event of concurrent generation (the C code
/// generates sequences serially by design, but the mutex is cheap and
/// harmless).
struct SequenceCollector {
    sequences: Vec<Vec<u16>>,
}

/// C callback invoked for each generated sequence.  It copies the sequence
/// into a Rust vector and appends it to the collector maintained in
/// `user_data`.  Safety: this function must not panic or unwind across the
/// FFI boundary.  The caller must ensure that `user_data` points to a valid
/// `SequenceCollector`.
extern "C" fn collect_sequence(seq_ptr: *const u16, length: usize, user_data: *mut c_void) {
    // SAFETY: The C engine passes a pointer to `length` elements of type
    // uint16_t.  We construct a slice view of that memory.  The memory
    // remains valid until we return from this callback because the C engine
    // reuses its own buffer for each call and does not free it until
    // generation is complete.
    let slice = unsafe { std::slice::from_raw_parts(seq_ptr, length) };
    let collector = unsafe { &mut *(user_data as *mut SequenceCollector) };
    collector.sequences.push(slice.to_vec());
}

/// Generate all sequences of a given length from the supplied list of ports.
/// This function internally invokes the C engine and collects the sequences
/// into a Rust vector.  Because the number of sequences grows exponentially
/// with the length of the sequence and the number of ports, callers should
/// ensure that the result will be of manageable size before invoking this
/// function.  Use `count_sequences()` to estimate the number of sequences.
pub fn generate_sequences_rust(ports: &[u16], seq_len: usize) -> Vec<Vec<u16>> {
    let mut collector = SequenceCollector { sequences: Vec::new() };
    unsafe {
        generate_sequences(
            ports.as_ptr(),
            ports.len(),
            seq_len,
            collect_sequence,
            &mut collector as *mut _ as *mut c_void,
        );
    }
    collector.sequences
}

/// Compute the number of sequences that would be generated by
/// `generate_sequences_rust()` without actually producing them.  This simply
/// computes `ports.len().pow(seq_len)` and is implemented in the C engine for
/// consistency.
pub fn total_sequence_count(num_ports: usize, seq_len: usize) -> u64 {
    unsafe { count_sequences(num_ports, seq_len) }
}

/// Attempt a TCP connection to `host:port` with a timeout expressed in
/// milliseconds.  Returns `true` if the connection succeeded, `false` if it
/// failed or timed out.  This helper abstracts away the boilerplate of
/// creating a future and applying a timeout.  It does not propagate errors
/// beyond returning false.
async fn try_tcp(host: &str, port: u16, timeout_ms: u64) -> bool {
    let addr = (host, port);
    let connect_future = TcpStream::connect(addr);
    match time::timeout(Duration::from_millis(timeout_ms), connect_future).await {
        Ok(Ok(stream)) => {
            // Successfully connected; close the stream immediately to avoid
            // lingering connections on the remote host.
            let _ = stream.shutdown().await;
            true
        }
        _ => false,
    }
}

/// Send a UDP datagram to `host:port`.  Returns `true` if the datagram was
/// sent successfully, `false` otherwise.  Unlike TCP, UDP has no notion of
/// connection success, so we treat any inability to send as a failure.  The
/// function binds a random local port for the duration of the send.
async fn try_udp(host: &str, port: u16) -> bool {
    match UdpSocket::bind("0.0.0.0:0").await {
        Ok(socket) => match socket.send_to(&[], (host, port)).await {
            Ok(_) => true,
            Err(_) => false,
        },
        Err(_) => false,
    }
}

/// Perform a mixed knock sequence where each port may use a different protocol.
/// The `ports` and `protocols` slices must have the same length.  The function
/// executes each knock in order, waiting `delay_ms` between knocks, and
/// attempts to connect to the monitor port afterwards.  Returns `true` if
/// the monitor port accepts a TCP connection.
async fn perform_mixed_knock_and_check(
    host: &str,
    ports: &[u16],
    protocols: &[Protocol],
    delay_ms: u64,
    monitor_port: u16,
    timeout_ms: u64,
) -> bool {
    for (port, proto) in ports.iter().zip(protocols.iter()) {
        match proto {
            Protocol::Tcp => {
                let _ = try_tcp(host, *port, timeout_ms).await;
            }
            Protocol::Udp => {
                let _ = try_udp(host, *port).await;
            }
        }
        time::sleep(Duration::from_millis(delay_ms)).await;
    }
    try_tcp(host, monitor_port, timeout_ms).await
}

/// Generate all possible protocol assignments for a given sequence length.
/// Each assignment is a vector of `Protocol` values (Tcp or Udp).  The
/// resulting vector has length 2^`seq_len`.  This helper is used by
/// mixed scanning to iterate over all combinations of TCP and UDP knocks.
fn generate_protocol_assignments(seq_len: usize) -> Vec<Vec<Protocol>> {
    let mut assignments = Vec::new();
    // There are 2^seq_len possible assignments.  We treat each assignment
    // as a bitmask where a set bit corresponds to UDP and a clear bit to TCP.
    let total = 1u64 << seq_len;
    for mask in 0..total {
        let mut proto_vec = Vec::with_capacity(seq_len);
        for i in 0..seq_len {
            let is_udp = (mask >> i) & 1 == 1;
            proto_vec.push(if is_udp { Protocol::Udp } else { Protocol::Tcp });
        }
        assignments.push(proto_vec);
    }
    assignments
}

/// Scan all sequences when mixed protocols are allowed.  For each port
/// sequence of length `seq_len`, this function generates all possible
/// protocol assignments (TCP/UDP for each position) and tests them.  A
/// match is recorded only when the monitor port opens after executing
/// a particular protocol assignment on a given sequence.  The return
/// value is a vector of tuples: `(sequence of ports, sequence of protocols)`.
pub async fn scan_sequences_mixed(
    host: String,
    ports: Vec<u16>,
    seq_len: usize,
    delay_ms: u64,
    monitor_port: u16,
    timeout_ms: u64,
    max_concurrency: usize,
) -> Vec<(Vec<u16>, Vec<Protocol>)> {
    let port_sequences = generate_sequences_rust(&ports, seq_len);
    let proto_assignments = generate_protocol_assignments(seq_len);
    let semaphore = Arc::new(Semaphore::new(max_concurrency));
    let host_arc = Arc::new(host);
    let mut handles = Vec::new();
    for seq in port_sequences {
        for assignment in &proto_assignments {
            let permit = semaphore.clone().acquire_owned().await.unwrap();
            let host_clone = host_arc.clone();
            let seq_clone = seq.clone();
            let proto_clone = assignment.clone();
            handles.push(tokio::spawn(async move {
                let _permit = permit;
                let matched = perform_mixed_knock_and_check(
                    &host_clone,
                    &seq_clone,
                    &proto_clone,
                    delay_ms,
                    monitor_port,
                    timeout_ms,
                )
                .await;
                if matched {
                    Some((seq_clone, proto_clone))
                } else {
                    None
                }
            }));
        }
    }
    let mut results = Vec::new();
    for handle in handles {
        if let Ok(Some(pair)) = handle.await {
            results.push(pair);
        }
    }
    results
}

/// Perform the knock sequence followed by an attempt to connect to the
/// monitor port.  The sequence is defined as a vector of ports (all using
/// the same protocol) and is executed sequentially with a fixed interâ€‘knock
/// delay.  After the sequence completes, Knockraven will try to connect
/// (over TCP) to the `monitor_port`.  If the connection succeeds, the
/// sequence is considered a match and the function returns `true`.
async fn perform_knock_and_check(
    host: &str,
    sequence: &[u16],
    protocol: Protocol,
    delay_ms: u64,
    monitor_port: u16,
    timeout_ms: u64,
) -> bool {
    for port in sequence {
        match protocol {
            Protocol::Tcp => {
                let _ = try_tcp(host, *port, timeout_ms).await;
            }
            Protocol::Udp => {
                let _ = try_udp(host, *port).await;
            }
        }
        // wait between knocks to ensure the remote daemon can record them
        time::sleep(Duration::from_millis(delay_ms)).await;
    }
    // After completing the knock sequence, attempt to connect to the
    // monitor port using TCP.  If this succeeds, we assume the port was
    // opened as a result of the knock sequence.
    try_tcp(host, monitor_port, timeout_ms).await
}

/// Scan all sequences for a given host using the provided configuration.  The
/// function will generate sequences using the C engine and then schedule
/// concurrent tasks to perform each knock.  Concurrency is limited via a
/// semaphore to avoid overwhelming the network or the target host.  The
/// function returns a vector of sequences which successfully opened the
/// monitor port.
pub async fn scan_sequences(
    host: String,
    ports: Vec<u16>,
    seq_len: usize,
    protocol: Protocol,
    delay_ms: u64,
    monitor_port: u16,
    timeout_ms: u64,
    max_concurrency: usize,
) -> Vec<Vec<u16>> {
    // Precompute all sequences.  In future iterations this could be streamed
    // directly from the C engine into tasks rather than storing in memory.
    let sequences = generate_sequences_rust(&ports, seq_len);
    let total = sequences.len();
    let semaphore = Arc::new(Semaphore::new(max_concurrency));
    let host_arc = Arc::new(host);
    let mut handles = Vec::with_capacity(total);
    for seq in sequences {
        let permit = semaphore.clone().acquire_owned().await.unwrap();
        let host_clone = host_arc.clone();
        let seq_clone = seq.clone();
        handles.push(tokio::spawn(async move {
            let _permit = permit;
            let matched = perform_knock_and_check(
                &host_clone,
                &seq_clone,
                protocol,
                delay_ms,
                monitor_port,
                timeout_ms,
            )
            .await;
            if matched {
                Some(seq_clone)
            } else {
                None
            }
        }));
    }
    let mut found = Vec::new();
    for handle in handles {
        if let Ok(Some(seq)) = handle.await {
            found.push(seq);
        }
    }
    found
}